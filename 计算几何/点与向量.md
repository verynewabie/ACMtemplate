```c++
#include <bits/stdc++.h>
using namespace std;
const double PI=acos(-1);
struct point{
	double x,y;
	point(double a=0,double b=0):x(a),y(b){}
	point operator+(point p){
		return point(x+p.x,y+p.y);
	}
	point operator-(point p){
		return point(x-p.x,y-p.y);
	}
	point operator*(double p){
		return point(x*p,y*p);
	}
	point operator*(point p){//叉乘
		return this->x*p.y-this->y*p.x;
	}
	point operator/(double p){
		return point(x/p,y/p);
	}
	point rotate90(){//逆时针90
		return point(-y,x);
	}
	point rotate270(){//逆时针270
		return point(y,-x);
	}
	double dot(point p){
		return x*p.x+y*p.y;
	}
	double len(){
		return sqrt(x*x+y*y);
	}
	double angle(point p){
		return acos(dot(p)/p.len()/len());
	}
	point footpoint(point a,point b){//该点在ab上的垂足
		point x=*this-a,y=*this-b,z=b-a;
		double len1=x.dot(z)/z.len(),len2=-1.0*y.dot(z)/z.len();
		return a+z*(len1/(len1+len2));
	}
	point symmery(point a,point b){//该点关于ab的对称点
		return *this+(footpoint(a,b)-*this)*2; 
	}
	point rotate(double ang){//绕原点逆时针旋转ang角度
		ang*=PI/180;
		return {this->x*cos(ang)-this->y*sin(ang),this->x*sin(ang)+this->y*cos(ang)};
	}
	void show(){
		printf("%.12lf %.12lf\n",x,y);
	}
};
//求在两点中垂线上且到两点距离为s的点，即为d1，d2
void distance(point a,point b,double s,point& d1,point& d2){
	point c=(a+b)*0.5;
	point ca=a-c;
	double x=ca.len();
	double y=sqrt(s*s-x*x);
	point dc1=ca.rotate90();
	point dc2=ca.rotate270();
	dc1=dc1/dc1.len()*s;
	dc2=dc2/dc2.len()*s;
	d1=c+dc1;
	d2=c+dc2;
}
```

