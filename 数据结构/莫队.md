## 莫队

```cpp
#include<bits/stdc++.h>
#define x first 
#define y second
using namespace std;
typedef long long LL;
typedef pair<int,int> PII;
int read(){
    int x=0,f=1;
	char ch=getchar();
    while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
    while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
    return x*f;
}
const int INF=0x3f3f3f3f,N=5e4+10,M=2e5+10,S=1e6+10;
const double eps=1e-6;
int cnt[S],n,m,ans[M],w[N],id[N],len,res;
struct query{
    int l,r,num;
    bool operator<(const query& que)const{
        int a=id[l],b=id[que.l];
        if(a!=b) return a<b;
        else if(a%2==0)return r<que.r;
        else return r>que.r;
    }
}q[M];
void add(int x){
    cnt[x]++;
    if(cnt[x]==1) res++;
}
void sub(int x){
    cnt[x]--;
    if(cnt[x]==0) res--;
}
int main(){
    n=read();
    for(int i=1;i<=n;i++) w[i]=read();
    m=read();
    len=max(1,(int)sqrt((double)n*n/m));
    for(int i=1;i<=n;i++) id[i]=(i-1)/len;
    for(int i=1;i<=m;i++) q[i]={read(),read(),i};
    sort(q+1,q+m+1);
    for(int k=1,i=0,j=1;k<=m;k++){
        int num=q[k].num,l=q[k].l,r=q[k].r;
        while(i<r) add(w[++i]);
        while(i>r) sub(w[i--]);
        while(j<l) sub(w[j++]);
        while(j>l) add(w[--j]);
        ans[num]=res;
    }
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

##  带修莫队

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
//可以把每个块大小设为n的2/3次方,此时复杂度为n的5/3次方
using namespace std;
const int N = 10010, S = 1000010;
int n, m, mq, mc, len;
int w[N], cnt[S], ans[N];
struct Query{
	int id, l, r, t;
}q[N];
struct Modify{
	int p, c;
}c[N];
int get(int x){
	return (x - 1) / len;
}
bool cmp(const Query& a, const Query& b){
	int al = get(a.l), ar = get(a.r);
	int bl = get(b.l), br = get(b.r);
	if (al != bl) return al < bl;
	if (ar != br) return ar < br;
	return a.t < b.t;
}
void add(int x, int& res){
	if (!cnt[x]) res ++ ;
	cnt[x] ++ ;
}
void del(int x, int& res){
	cnt[x] -- ;
	if (!cnt[x]) res -- ;
}

int main(){
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);
	for (int i = 0; i < m; i ++ ){
		char op[2];
		int a, b;
		scanf("%s%d%d", op, &a, &b);
		if (*op == 'Q') mq ++, q[mq] = {mq, a, b, mc};
		else c[ ++ mc] = {a, b};
	}
	len = cbrt((double)n * max(1 , mc)) + 1;
	sort(q + 1, q + mq + 1, cmp);
	for (int i = 0, j = 1, t = 0, k = 1, res = 0; k <= mq; k ++ ){
		int id = q[k].id, l = q[k].l, r = q[k].r, tm = q[k].t;
		while (i < r) add(w[ ++ i], res);
		while (i > r) del(w[i -- ], res);
		while (j < l) del(w[j ++ ], res);
		while (j > l) add(w[ -- j], res);
		while (t < tm){
			t ++ ;
			if (c[t].p >= j && c[t].p <= i){
				del(w[c[t].p], res);
				add(c[t].c, res);
			}
			swap(w[c[t].p], c[t].c);
		}
		while (t > tm){
			if (c[t].p >= j && c[t].p <= i){
				del(w[c[t].p], res);
				add(c[t].c, res);
			}
			swap(w[c[t].p], c[t].c);
			t -- ;
		}
		ans[id] = res;
	}
	for (int i = 1; i <= mq; i ++ ) printf("%d\n", ans[i]);
	return 0;
}
```

## 回滚莫队

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 100010;
int n, m, len;
int w[N], cnt[N];
LL ans[N];
struct Query {
    int id, l, r;
} q[N];
vector<int> nums;
int get(int x) {
    return (x - 1) / len;
}
bool cmp(const Query &a, const Query &b) {//保证左端点固定，右端点递增
    int i = get(a.l), j = get(b.l);
    if (i != j)
        return i < j;
    return a.r < b.r;
}
void add(int x, LL &res) {
    cnt[x] ++ ;
    res = max(res, (LL)cnt[x] * nums[x]);
}
int main() {
    scanf("%d%d", &n, &m);
    len = sqrt(n);
    for (int i = 1; i <= n; i ++ )
        scanf("%d", &w[i]), nums.push_back(w[i]);
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    for (int i = 1; i <= n; i ++ )
        w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin();
    for (int i = 0; i < m; i ++ ) {
        int l, r;
        scanf("%d%d", &l, &r);
        q[i] = {i, l, r};
    }
    sort(q, q + m, cmp);
    for (int x = 0; x < m;) {//一次循环处理起点在一个块中的
        int y = x;
        while (y < m && get(q[y].l) == get(q[x].l))//[q[x],q[y])问询的左端点在该块
            y ++ ;
        int right = (get(q[x].l) + 1) * len - 1;
        while (x < y && q[x].r <= right) {
            LL res = 0;
            int id = q[x].id, l = q[x].l, r = q[x].r;
            for (int k = l; k <= r; k ++ )
                add(w[k], res);
            ans[id] = res;
            for (int k = l; k <= r; k ++ )
                cnt[w[k]] -- ;
            x ++ ;
        }
        LL res = 0;
        int i = right, j = right + 1;
        while (x < y) {
            int id = q[x].id, l = q[x].l, r = q[x].r;
            while (i < r)
                add(w[ ++ i], res);
            LL backup = res;
            while (j > l)
                add(w[ -- j], res);
            ans[id] = res;
            while (j < right + 1)
                cnt[w[j ++ ]] -- ;
            res = backup;
            x ++ ;
        }
        for (int i = right + 1; i <= q[x - 1].r; i++)
            cnt[w[i]]--;
    }
    for (int i = 0; i < m; i ++ )
        printf("%lld\n", ans[i]);
    return 0;
}
```

## 树上莫队

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100010;
int n, m, len;
int w[N];
vector<int> to[N];
int depth[N], fa[N][16];
int seq[N], top, first[N], last[N];
int cnt[N], st[N], ans[N];
struct Query{
    int id, l, r, p;
}q[N];
vector<int> nums;
void dfs(int u, int father){
    seq[ ++ top] = u;
    depth[u] = depth[father] + 1;
    first[u] = top;
    fa[u][0] = father;
    for (int k = 1; k < 16; k ++ )
        fa[u][k] = fa[fa[u][k-1]][k-1];
    for (auto j: to[u])
        if (j != father) 
            dfs(j, u);
    seq[ ++ top] = u;
    last[u] = top;
}
int lca(int a, int b){
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 15; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 15; k >= 0; k -- )
        if (fa[a][k] != fa[b][k]){
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}
int get(int x){
    return (x - 1) / len;
}
void add(int x, int& res){
    st[x] ^= 1;
    if (st[x] == 0){
        cnt[w[x]] -- ;
        if (!cnt[w[x]]) res -- ;
    }
    else{
        if (!cnt[w[x]]) res ++ ;
        cnt[w[x]] ++ ;
    }
}
int main(){    
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]), nums.push_back(w[i]);
    sort(nums.begin(), nums.end());
    nums.erase(unique(nums.begin(), nums.end()), nums.end());
    for (int i = 1; i <= n; i ++ )
        w[i] = lower_bound(nums.begin(), nums.end(), w[i]) - nums.begin();
    for (int i = 0; i < n - 1; i ++ ){
        int a, b;
        scanf("%d%d", &a, &b);
        to[a].push_back(b);
        to[b].push_back(a);
    }
    dfs(1, 0);
    for (int i = 0; i < m; i ++ ){
        int a, b;
        scanf("%d%d", &a, &b);
        if (first[a] > first[b]) swap(a, b);
        int p = lca(a, b);
        if (a == p) q[i] = {i, first[a], first[b]};
        else q[i] = {i, last[a], first[b], p};
    }
    len = sqrt(top);
    sort(q, q + m, [](const Query& a, const Query& b){
        int i = get(a.l), j = get(b.l);
        if (i != j) return i < j;
        if (i % 2 == 0) return a.r < b.r;
        return a.r > b.r;
    });
    for (int i = 0, L = 1, R = 0, res = 0; i < m; i ++ ){
        int id = q[i].id, l = q[i].l, r = q[i].r, p = q[i].p;
        while (R < r) add(seq[ ++ R], res);
        while (R > r) add(seq[R -- ], res);
        while (L < l) add(seq[L ++ ], res);
        while (L > l) add(seq[ -- L], res);
        if (p) add(p, res);
        ans[id] = res;
        if (p) add(p, res);
    }
    for (int i = 0; i < m; i ++ ) printf("%d\n", ans[i]);
    return 0;
}
```

