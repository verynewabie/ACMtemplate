```cpp
#define ls t[x].l
#define rs t[x].r
using namespace std;
const int N = 200005;
struct T{
    int l, r, v, d, f;
    // l, r 表示左右儿子, v 表示值
    // d 表示从当前节点到最近叶子节点的距离, f 表示当前节点的父亲
} t[N];
int find(int x) {
    return t[x].f == x ? x : t[x].f = find(t[x].f);
}
int merge(int x, int y) { // 递归合并函数
    if (!x || !y) return x + y;
    if (t[x].v > t[y].v || (t[x].v == t[y].v && x > y)) swap(x, y);
    rs = merge(rs, y);
    if (t[ls].d < t[rs].d) swap(ls, rs);
    t[x].d = t[rs].d + 1;
    return x;
}
int work(int x, int y) { // 合并 x, y 两个堆。
    if (x == y) return 0;
    if (!x || !y) return t[x + y].f = x + y;
    if (t[x].v > t[y].v || (t[x].v == t[y].v && x > y)) swap(x, y);
    t[x].f = t[y].f = x;
    merge(x, y); return x;
}
void del(int x) {
    t[x].f = work(ls, rs);
}
int m, n;
int main() {
    scanf("%d", &m);
    while (m--) {
        int opt; scanf("%d", &opt);
        if (opt == 1) {
            int x; scanf("%d", &x);// 新建一个堆
            t[n].f = ++n, t[n].v = x, t[n].d = 1;
        } else if (opt == 2) {// 第 x 个插入的数和第 y 个插入的数所在堆合并
            int x, y; scanf("%d%d", &x, &y);
            work(find(x), find(y));
        } else if (opt == 3) {// 查询第 x 个插入的数所在堆的最值
            int x; scanf("%d", &x);
            printf("%d\n", t[find(x)].v);
        } else {// 删除第 x 个插入的数所在堆的最值
            int x; scanf("%d", &x);
            del(find(x));
        }
    }
}
```

