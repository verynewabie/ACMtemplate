## 线段树分裂与合并

```c++
#include<bits/stdc++.h>
#define ls tr[u].l
#define rs tr[u].r
using namespace std;
const int N=1e5+10;
//刻意卡的话优化并没有什么用处
int idx,use[N*70],tt,rt[N],splitroot;
struct node{
	int l,r;
}tr[N*70];//空间复杂度mlogn，m是点的个数，n是权值线段树的权值数
void pushup(int u){
	/*
		pushup
	*/
}
int newnode(){
	if(tt) return use[tt--];
	else return ++idx;
}
void del(int& u){
	use[++tt]=u;
	tr[u]={0,0};
	u=0;
}
void merge(int& a,int& b,int l,int r){
	if(!a||!b){
		a+=b;
		b=0;
		return ;
	}
	if(l==r){
		/*
			merge
		*/
		del(b);
		return ;
	}
	int mid=l+r>>1;
	merge(tr[a].l,tr[b].l,l,mid);
	merge(tr[a].r,tr[b].r,mid+1,r);
	pushup(a);
	del(b);
}
void update(int& u,int l,int r,int now){
	if(!u) u=newnode();	
	if(l==r){
		/*
			update
		*/
		return ;
	}
	int mid=l+r>>1;
	if(now<=mid) update(tr[u].l,l,mid,now);
	else update(tr[u].r,mid+1,r,now);
	pushup(u);
}
void split(int& p,int &q,int l,int r,int str,int ed){
	if(!p) return ;
	if(l>=str&&r<=ed){
		q=p;
		p=0;
		return ;
	}
	if(!q) q=newnode();
	int mid=l+r>>1;
	if(str<=mid) split(tr[p].l,tr[q].l,l,mid,str,ed);
	if(ed>mid) split(tr[p].r,tr[q].r,mid+1,r,str,ed);
	pushup(q),pushup(p);
} 
/*树上非常省内存的写法，一般8n就够了
void dfs(int u,int fa){
	先遍历
	for(auto j:to[u]){
		if(j==fa) continue;
		dfs(j,u);
	}
	更新该节点
	update(rt[u],w[u],1,n);
	计算该点答案
	//
	if(fa) merge(rt[fa],rt[u])
}
*/
```



## 可持久化线段树

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=1e5;
struct node{
	int l,r;
	int cnt;
}tr[N*21];
int root[N],idx,n,w[N];
void insert(int& u,int old,int l,int r,int pos,vector<int>& type){
	u=++idx;
	tr[u]=tr[old];
	if(l==r){
		tr[u].cnt++;
		return ;
	}
	int mid=l+r>>1;
	if(pos<=mid) insert(tr[u].l,tr[old].l,l,mid,pos,type);
	else insert(tr[u].r,tr[old].r,mid+1,r,pos,type);
	tr[u].cnt=tr[tr[u].l].cnt+tr[tr[u].r].cnt;
}
int query(int p,int q,int l,int r,int mi,int ma,int type){
	if(l>=mi&&r<=ma){
		return tr[q].cnt-tr[p].cnt;
	}
	int mid=l+r>>1,ans=0;
	if(mi<=mid) ans+=query(tr[p].l,tr[q].l,l,mid,mi,ma,type);
	if(ma>mid) ans+=query(tr[p].r,tr[q].r,mid+1,r,mi,ma,type);
	return ans;
}
```

## 李超线段树

```cpp
struct node{
	int l,r;
	int id;
}tr[N*4];
struct line{
	double k,b;
}lines[N];
double calc(const line& a,int x){//第pos个直线上
	return a.k*x+a.b;
}
int query(int u,int x){
	if(tr[u].l==tr[u].r) return tr[u].id;
	int mid=tr[u].l+tr[u].r>>1,tmp=0;
	if(x<=mid) tmp=query(u<<1,x);
	else tmp=query(u<<1|1,x);
	if(calc(lines[tmp],x)>calc(lines[tr[u].id],x)) 
		return tmp;
	else return tr[u].id;
}
void update(int u,int l,int r,int id){
	int mid=tr[u].l+tr[u].r>>1;
	if(tr[u].l>=l&&tr[u].r<=r){
		if(calc(lines[id],mid)>calc(lines[tr[u].id],mid)) swap(tr[u].id,id);
		if(calc(lines[id],tr[u].l)>calc(lines[tr[u].id],tr[u].l))
			update(u<<1,l,r,id);
		if(calc(lines[id],tr[u].r)>calc(lines[tr[u].id],tr[u].r))
			update(u<<1|1,l,r,id);
		return ;
	}
	if(l<=mid) update(u<<1,l,r,id);
	if(r>mid) update(u<<1|1,l,r,id);
}
//插入
int x0=read(),y0=read(),x1=read(),y1=read();
if(x1<x0) swap(x1,x0),swap(y1,y0);
if(x0==x1) lines[i]={0,max(y0,y1)};
else lines[i].k=(double)(y1-y0)/(x1-x0),lines[i].b=y1-lines[i].k*x1;
update(1,x0,x1,cnt);
```

